如何设计高可用系统，基于标准化和验证

标准化： 使用逻辑和连接分解系统到具体的实体，每个实体具有明确的边界，并且可以独立存在运行。

核心原理： 提升单点robustless 以及避免单点故障，快速响应故障之后的恢复。

標準操作流：

1.架構設計 FMEA 循證醫學 經驗專家系統輔助， 核心是硬件的主備。

2.代碼 與框架選擇

3.代碼fuzz測試

4.集成接口的fuzz 性能 健壯性測試

5.驗證主備切換效果。

6.風險評估與監測。







測試工具



https://testng.org/doc/documentation-main.html

junit5

fuzz peach  google fuzz pit






































参考 

要设计一套撸棒性强的系统，核心在于缓存，层层缓存。
从 cdn 缓存到 view 层缓存到业务逻辑缓存到数据库缓存到内存缓存到 cpu 一级二级等缓存。
如果用 django ，就应该抛弃他的模板渲染。
只基于 restful 输出 json ，然后基于 nodejs 做模板数据组装与 json 数据缓存。
然后用户前端完全可以使用 reactjs/angularjs 做单页 web 应用，这样可以节省许多无意义的 html 数据流量，很大程度节省服务器带宽。
nginx 和 nodejs 以及 redis 的异步 IO/事件驱动模型天生就是为这种高并发的 io 请求而生的。
说完 web 说业务逻辑，业务逻辑可以设计的很美。
比如创作社区，可以解耦和为博客系统，论坛系统，图片(文件)存储系统，评论系统，用户系统等。
各个系统之间使用 restful/webservice/私有协议/异步队列来进行相互之间的通信。
哪一个系统的模块如果成为瓶颈，那么就给这个模块增加相应的机器 /容器。
用户多了后图片系统撑不住，负荷大大超出其他系统，那么可以给图片系统增加机器。
在这方面， docker 是个很好的容器工具。
一个系统拆分成一个一个足够小足够好的模块后，各模块就变成的单独的服务， a 如果依赖 b ，那么 a 直接调用 b 的服务接口。
一个系统里模块多的话，你调用我我调用你，调用关系就会变得很复杂，变成一个网。
*** 这时候就需要引入服务治理，需要一个注册中心给各个服务自己注册。
java 方面阿里巴巴在这块专门有一个 dubbo 框架，基于 netty 的一个异步非阻塞的 nio 网络框架。 python 方面我还不了解。 ***
再说业务缓存，业务缓存的设计是最能体现出一个程序员理解和提炼需求，掌控业务的能力，
*** 基于 aop 的拦截机制 ***，哪些方法该走缓存，什么时候该刷新缓存，分布式缓存下如何做到数据的同步，这些都是细微之处见真功。
再说数据库层面，既然选了 mongodb ，读写分离，索引什么的就不说了，如何做到基于业务的请求，少查询库。
返回部分 json 也是调优特别该注意的地方。
数据量上来的话，可以考虑数据分片，这方面， hadoop 等都不错。
再说操作系统层面， linux 内核级的调优， http 连接数，最大打开文件数等等，可以优化的地方太多了。
转载的是某个帖子的回复，当时复制粘贴了下来，出处已经找不到了。


方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。

保证系统高可用，架构设计的核心准则是：冗余。

有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“自动故障转移”来实现系统的高可用。

接下来我们看下典型互联网架构中，如何通过冗余+自动故障转移来保证系统的高可用特性。


架构：

究竟啥才是互联网架构“高可用”

https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959728&idx=1&sn=933227840ec8cdc35d3a33ae3fe97ec5&chksm=bd2d046c8a5a8d7a13551124af36bedf68f7a6e31f6f32828678d2adb108b86b7e08c678f22f&scene=21#wechat_redirect


https://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&mid=2247490179&idx=1&sn=58805326e028442b8519ed215c9539d4&chksm=e8d7e541dfa06c57c1a9a00c3e341be3db932e8985bcdb772e305137e2c760f2cecbfa70f067&scene=27#wechat_redirect

spring cache：

http://www.importnew.com/30640.html

https://mp.weixin.qq.com/s?__biz=MzAxODcyNjEzNQ==&mid=2247485096&idx=1&sn=e696d44cf25d533945d70168b43409cb&chksm=9bd0ab30aca72226ff5338c07115c90750cea92d28077f2f615fd071404191288999c9d07a99&scene=27#wechat_redirect




redis：

https://mp.weixin.qq.com/s?__biz=MzIwMzY1OTU1NQ==&mid=2247484334&idx=1&sn=17a123cb83c62450581c05fabd586679&chksm=96cd43e2a1bacaf499bb706ad021c606353edcce3df83df36df46eaa365ace4630e4fe6702a7&scene=27#wechat_redirect

https://mp.weixin.qq.com/s?__biz=MzA4NTU2MTg3MQ==&mid=2655165392&idx=1&sn=679a226f4ffecc152ca222e13cd8df9a&chksm=84603cb0b317b5a677fab4f69238062cad6e17c69a938d74f1027f413329727410d6c97705bd&scene=27#wechat_redirect


https://zhuanlan.zhihu.com/p/43723276

https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=207266993&idx=1&sn=403b573a8c0938dc047c30c1a6688889&scene=27#wechat_redirect

https://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&mid=2247490239&idx=1&sn=33fe523912bfd2d09dd4f97053bbc97b&chksm=e8d7e57ddfa06c6b9a9202de049606cf5b8029d79ca8c756f66155ebc82bc9c6f912e4ea7b57&scene=27#wechat_redirect


https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651960393&idx=1&sn=23cf8438b436c531c81b3f09a3d5e8fb&chksm=bd2d01958a5a88838e6ef493ccb1fe0854f7216f3863fbe9798eec5019dc58d73d4e95b3132f&scene=27#wechat_redirect

mysql高可用

https://www.infoq.cn/article/2018%2F07%2Fgithub-mysql-high-availability

https://mp.weixin.qq.com/s?__biz=MzI5ODQ2MzI3NQ==&mid=2247484578&idx=1&sn=6b9f90e89379921f54b75da202975c4a&chksm=eca43de6dbd3b4f0e566609f03de4875d5e6bf3f74dd218f702907540c917ec222fd76ac1c97&scene=27#wechat_redirect

网关性能

https://www.infoq.cn/article/comparing-api-gateway-performances

突发热点事件下微博高可用注册中心 vintage 的设计 & 实践

https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959601&idx=1&sn=5684c39676b1f6d9366d9d15a2cdcec3&scene=21#wechat_redirect

https://www.infoq.cn/article/mysql-high-availability-at-github

在这片文章中，我将会介绍，我想到的方法．
TDD(测试驱动开发)
尽管这个在业界似乎还不是很流行，但是它对于保证代码的健壮性很重要．我们开发人员中的很多人，在开发完成后，不会写测试用例来对代码进行完整的测试．比如说，对于一个修改用户信息的功能，可能只会测试正确的输入．而对于那些异常情况，比如，我们知道，修改用户信息的接口，一定是需要传一个用户的uuid来识别是修改的哪位用户的信息，而用户(这里我们称前台开发人员为用户)在调用的时候，可能并没有传用户的uuid的情况，并不会测试到．对于这种情况，不够健壮的代码会给出500，服务器错误，而健壮的代码会给你一个错误信息，告诉你缺少了必要的参数．在我们的服务中，格式为:
{
    "code": "error_code",
    "data": "error_message"
}

但是如果我们在开发之前，确定下来我们的模块需要拥有的接口，以及接口需要的参数，进一步确定可能会有什么错误发生，并提前写好相应的测试脚本．在开发完成后，执行一下测试脚本，便能发现代码中的错误，代码还会不健壮吗？
还是上面那个例子，修改用户的信息的接口，假设我们允许修改的用户信息有:

用户昵称(长度最长为20个字节，即最长20个英文单词，10个汉字)(必须传入)
用户性别(1代表男，2代表女)(必须传入)
用户出生日期(格式为YYYY-MM-DD)(必须传入)
用户简介(长度最长为40个字节，即最长40个英文单词，20个汉字)(必须传入)

我们可以确定可能有下面的异常情况：

用户没有传入表明用户身份的uuid
用户传入了一个错误的uuid,即不存在的用户
用户没有传入必要的参数，比如缺少用户昵称，用户性别等
用户传了不合法的参数，比如传入了用户的密码
传入的用户昵称为null
传入的用户昵称为""(即空字符串)
传入的用户昵称长度大于20字节
传入的用户昵称为不支持的字符编码
传入的用户性别格式不正确，比如传入'woman'
传入的用户性别的取值不正确，比如传入了'3'
传入的用户出生日期格式不正确，比如传入的格式为'YYYY-MM-DD hh:mm:ss'
传入的用户出生日期取值不正确，比如现在是2017年，他传入的用户年份是2018或者1800，传入的月份是13,等
传入的用户简介为null
传入的用户简介为""(即空字符串)
传入的用户简介长度大于40字节
传入的用户简介为不支持的字符编码
用户传入了正确的数据但是返回的结果不正确

我们根据上面可能的异常情况以及正确输入写一个测试脚本，在Java中，对于Restful接口，我们使用Rest Assured库．开发完成之后，只需执行一下测试脚本，就能发现程序中存在哪些错误．
做回归测试
我们在修复一个issue,或者增加新的接口的时候，并不能确保我们的修改对其他接口没有影响．所以，我们还需要做回归测试．如果上面写了TDD的测试脚本，那这里我们只需要在这个脚本中新增新接口的测试用例，再执行一遍测试就Ok了．如果没有上面的那个脚本，这里你也很可能就会因为嫌麻烦而不做．
我们项目组中的成员，很多次就是因为没有执行回归测试，而导致新接口能用而旧接口失效的问题．
将生产环境下数据库需要的约束同样加在开发环境下
数据库约束其实也是提高我们的代码健壮性的一个好帮手．比如，在新增用户的粉丝接口中(用户和粉丝的关系在一张单独的表中)，我们需要用户传入的粉丝id是一个存在的用户的uuid．如果不用约束，我们需要在代码中先遍历数据库来查询用户是否存在，而如果我们直接使用外键约束，让粉丝id是用户id的外键，那么我们只需要查看数据库是否返回违反外键约束的错误就能确定用户是否存在了．
在修改用户信息的那个例子中，如果你没有先写测试脚本，忘了判断用户昵称是否为空，而你数据库中，用户昵称字段有非空约束．通过传入空昵称时这个非空约束报的错误，你就能知道需要先判断用户昵称是否为空．
永远不要认为你依赖的东西会正常工作
作为一个后台微服务，我们一定会用到数据库，会用到缓存．如果你假设数据库不会宕机，并没有处理数据库宕机的代码，那你的代码永远都不够健壮．一旦数据库宕机，前台就会返回大量的500，有心人就会有可乘之机了．
做压力测试
有的错误，如果你不做压力测试，是察觉不到的．比如，不正确的并发处理，死锁等问题．对于一个点赞接口来说，如果你用postman来进行测试，点一次结果正确，点两次结果正确，但是你并发的点一万次，结果可能就会因为并发处理不对而是9990了．
如果你没用数据库连接池，网络带宽足够大，并发执行十万次数据库写操作，数据库可能就会因此宕机(至少会有明显的网路延时)，这时候如果你的微服务如果对外提供正确的错误信息，那恭喜，你的代码足够健壮了．


