#  Java 11

## 序列化过滤

现在可以使用java序列化过滤机制来帮助防止反序列化漏洞.你可以定义基于pattern的过滤器.也可以创建自定义过滤器.

* 解决反序列化漏洞
* java序列化过滤器
* 黑白名单
* 创建基于pattern的过滤器
* 创建自定义过滤器
* 内置过滤器
* 记录过滤器操作




### 解决反序列化漏洞

    创建过滤器时,可以指定应用程序可接收的类.以及应该拒绝的类.你可以在反序列化期控制对象的图的大小和复杂性.以便对象图不会超出合理的限制.过滤器可以配置为属性,也可以通过编程方式实现.

    除了创建过滤器之外,你还可以采用以下操作来防止反序列化漏洞:
    不反序列化任何不受信任的数据.
    使用SSL加密和颜泽应用程序之间的连接.
    在复制之前验证字段值.包括使用readObject方法检测对象的不变量
    jdk为RMI提供了内置过滤器.但是你应该只使用这些内置过滤器作为起点.配置黑名单或扩展白名单,为使用RMI的应用天机额外保护.


### java序列化过滤器

    java序列化过滤机制筛选序列化对象的传入字节流,以帮助提高安全性和健壮性.过滤器可用在反序列化之前验证传入的类.

    如JEP 290中所述，Java序列化过滤机制的目标是： 提供一种方法来将可以反序列化的类缩小到适合上下文的类集。
    在反序列化期间为过滤器提供图表大小和复杂性的度量标准，以验证正常的图形行为。
    允许RMI导出的对象验证调用中所需的类。
    您可以通过以下方式实现序列化过滤器：
    基于pattern的过滤器不需要你修改应用的代码.它们由属性,匹配文件或命令行中定义的一系列pattern组成·基于pattern的过滤器可用接收或拒绝特定的类,包和模块.它们可以限制数组大小,图行深度,总引用和流大小.一个典型的用例是将已被识别为可能危及java运行的类列入黑名单.基于pattern的过滤器是为一个应用程序或过程中的所有应用程序定义的。
    自定义过滤器使用ObjectInputFilter api实现.它们允许应用程序集成比基于pattern的过滤器更精细的控制,因为它们可以使用特定一每个ObjectInputStream。自定义过滤器可以设置在单个输入流或进程中的所有流上。
    为流中的每个新对象调用过滤器机制.如果存在多个活动过滤器(过程范围过滤器,应用程序过滤器或流特定过滤器),则仅调用最具体的过滤器.
    在大多数情况下,自定义过滤器赢检查是否设置了过程范围的过滤器.如果存在,则自定义筛选器应调用并使用流程范围的筛选器结果,除非状态为UNDECIDED.
    从JDK 9开始，以及从8u121,7u131和6u141开始的Java CPU版本中包括对序列化过滤器的支持。

###  黑白名单

    黑明白名单可以通过基于pattern或者自定义的过滤器实现.这些列表允许您采取主动和防御性方法来保护您的应用程序。

    主动方法使用白名单仅接受已识别和受信任的类.你可以在开发应用时在代码中实现白名单,也可以稍后通过定义基于pattern的过滤器来实现白名单.如果你的应用只处理以小组类,那么这种方法可以很好的工作.你可以通过制定允许的类,包或者模块来实现白名单.
    防御方法使用黑名单来拒绝不信任的类.通常,黑名单是在发现一个类是一个问题的攻击之后实现的.通过定义基于pattern的过滤器,可以将类添加到黑名单中,而唔需要更改代码.



###  创建基于模糊匹配的过滤器


## Process(进程) API

    Process API允许您启动，检索有关本机操作系统进程的信息并对其进行管理。
    使用此API，您可以按如下方式使用操作系统进程：
    运行任意命令
    过滤正则运行的进程。
    重定向输出
    通过调度进程来连接异构命令和shell，以便在另一个结束时启动。
    测试命令的执行
    运行一系列测试。
    记录输出。
    清理剩余的进程。
    监控命令
    监视长时间运行的进程并在它们终止时重新启动它们
    收集使用统计信息

###

### 



# 参考

https://github.com/dapr/dapr
https://vitzhou.gitbooks.io/study-java11/language/lib/serialization_filtering.html