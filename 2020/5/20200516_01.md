#  Java 11 核心库


## 

* 序列化过滤

* 增强的弃用

* XML目录API

* 创建不可修改的列表，集合和地图

* 流程API

* 首选项API

* Java记录概述




## s使用@Deprecated注释

    要表明已弃用，请在模块，类，方法或成员声明之前加上@Deprecated。批注包含以下元素：

    @Deprecated（since =“ <version>”）

    <version>是不推荐使用的API的版本。这仅供参考。默认值为空字符串（""）。

    @Deprecated（forRemoval = <boolean>）

    forRemoval = true表示该API将在将来的版本中删除。

    forRemoval = false建议代码不应再使用此API。但是，目前没有删除该API的意图。这是默认值。

    例如：@Deprecated（since =“ 9”，forRemoval = true）

    所述@Deprecated注释导致要标有以下中的一个，无论该程序元素出现的Javadoc生成的文档：
    不推荐使用。

    不推荐使用，以便删除：此API元素可能会在将来的版本中删除。

    该javadoc工具将生成一个名为的页面deprecated-list.html，其中包含已弃用的API列表，并在导航栏中添加指向该页面的链接。

    以下是使用java.lang.Thread类中的@Deprecated批注的简单示例：

## 运行jdeprscan

[jdeprscan](https://docs.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/core&id=JSWOR-GUID-2B7588B0-92DB-4A88-88D4-24D183660A62)是一种静态分析工具，它报告应用程序对已弃用的JDK API元素的使用情况。运行jdeprscan以帮助识别编译的类文件或jar文件中的可能问题。

    您可以从编译器通知中找到不赞成使用的JDK API。但是，如果您不对每个JDK版本都进行重新编译，或者警告被抑制，或者您依赖于作为二进制工件分发的第三方库，则应该运行jdeprscan。

    在从JDK中删除API之前，发现对不赞成使用的API的依赖性很重要。如果二进制文件使用的API在当前JDK版本中已被弃用，并且不进行重新编译，则不会收到任何通知。在将来的JDK版本中删除API时，二进制文件将在运行时完全失败。jdeprscan现在，您可以在删除API之前检测到这种用法。

    有关如何运行该工具以及如何解释输出的完整语法，请参见jdeprscan《Java Platform，Standard Edition Tools Reference》。


##  创建不可修改的列表，集合和映射
    通过List，Set和Map接口方便的静态工厂方法，可以轻松创建不可修改的列表，集合和映射。

    如果无法添加，删除或替换元素，则认为集合不可修改。创建集合的不可修改的实例后，只要存在对它的引用，它就会保存相同的数据。

    可修改的集合必须维护簿记数据以支持将来的修改。这增加了存储在可修改集合中的数据的开销。不可修改的集合不需要此额外的簿记数据。由于不需要修改集合，因此可以更密集地打包集合中包含的数据。与包含相同数据的可修改集合实例相比，不可修改的集合实例通常消耗更少的内存。

    主题

    用例

    句法

    创建馆藏的不可修改副本

    从流创建不可修改的集合

    随机迭代顺序

    关于不可修改的收藏

    空间效率

    线程安全
    用例
    使用不可修改的集合还是可修改的集合取决于集合中的数据。

    不可修改的集合可提高空间效率，并防止意外修改集合，否则可能导致程序无法正常工作。对于以下情况，建议使用不可修改的集合：

    从编写程序时已知的常量初始化的集合
    在程序开始时从计算出的数据或从诸如配置文件之类的数据中读取的数据初始化的集合
    对于保存在整个程序过程中都被修改过的数据的集合，可修改的集合是最佳选择。修改是就地执行的，因此增量或删除数据元素非常便宜。如果使用不可修改的集合来完成此操作，则必须制作完整的副本以添加或删除单个元素，这通常会带来不可接受的开销。

    句法
    这些新集合的API非常简单，尤其是对于少量元素而言。

##  流程API

    使用Process API，您可以启动，检索有关本机操作系统进程的信息并进行管理。

    使用此API，您可以按如下方式使用操作系统进程：

    运行任意命令：

    筛选正在运行的进程。

    重定向输出。

    通过调度进程在另一个结束时启动来连接异构命令和外壳程序。

    测试命令的执行：

    运行一系列测试。

    日志输出。

    清理剩余的进程。

    监视命令：

    监视长时间运行的进程，并在终止时重新启动它们

    收集使用情况统计

##  首选项API

    使用Preferences API，应用程序可以管理首选项和配置数据。

    应用程序需要首选项和配置数据，以适应不同用户和环境的需求。所述的java.util.prefs包提供应用程序来存储和检索用户和系统参数和配置数据的方法。数据永久存储在与实现相关的后备存储中。偏好节点有两棵单独的树，一棵用于用户偏好，一棵用于系统偏好。

    所有修改首选项数据的方法都允许异步操作。它们可能会立即返回，并且更改最终将传播到持久性后备存储。的冲洗方法可用于强制更新到后备存储器。

    Preferences类中的方法可以由单个JVM中的多个线程并发调用，而无需外部同步，并且结果将等效于某些串行执行。如果此类由多个将其首选项数据存储在同一后备存储中的JVM并发使用，则该数据存储将不会被破坏，但是不会对首选项数据的一致性做出其他保证。

    主题：

    将首选项API与其他机制进行比较

    使用说明

    设计常见问题

    将首选项API与其他机制进行比较
    在引入首选项API之前，开发人员可以选择通过使用属性API或Java命名和目录接口（JNDI）API临时管理首选项和配置数据。

    通常，首选项和配置数据存储在属性文件中，可以通过java.util.Properties API 访问。但是，对于此类文件应驻留在磁盘上的位置或应调用的位置，没有任何标准。使用这种机制，备份用户的首选项数据或将其从一台计算机传输到另一台计算机极为困难。随着应用程序数量的增加，文件名冲突的可能性也会增加。同样，此机制在缺少本地磁盘的平台上或希望将数据存储在外部数据存储区（例如企业范围的LDAP目录服务）中也无济于事。

    开发人员不太频繁地将用户首选项和配置数据存储在通过JNDI API访问的目录服务中。与Properties API不同，JNDI允许使用任意数据存储（后端中立）。尽管JNDI非常强大，但它也相当大，由5个包和83个类组成。对于应在目录名称空间中存储首选项数据的位置，还是在哪个名称空间中，JNDI没有提供任何策略。

    Properties和JNDI都没有提供简单，无处不在的后端中立偏好管理工具。Preferences API确实提供了这样的功能，将Properties的简单性与JNDI的后端中立性结合在一起。它提供了足够的内置策略，可防止名称冲突，促进一致性并在无法备份数据存储的情况下增强鲁棒性。

    使用说明
    本节中的信息不是Preferences API规范的一部分。旨在提供一些示例说明如何使用Preferences API。


##  Java日志概述

    包java.util.logging中包含的Java Logging API 通过生成适合最终用户，系统管理员，现场服务工程师和软件开发团队进行分析的日志报告，促进了客户站点的软件服务和维护。日志API捕获信息，例如安全失败，配置错误，性能瓶颈和/或应用程序或平台中的错误。

    核心软件包包括支持将纯文本或XML格式的日志记录传递到内存，输出流，控制台，文件和套接字。此外，日志记录API能够与主机操作系统上已经存在的日志记录服务进行交互。


    


# 参考
https://github.com/dapr/dapr
https://docs.oracle.com/en/java/javase/11/core/java-core-libraries1.html